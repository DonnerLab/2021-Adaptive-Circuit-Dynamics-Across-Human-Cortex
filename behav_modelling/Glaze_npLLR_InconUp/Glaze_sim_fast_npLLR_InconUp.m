% Script for simulating behaviour generated by Glaze et al. normative model
% during two-alternative sequential evidence accumulation task where
% samples are drawn from one of 2 distributions with same std but different
% means, and mean can switch at fixed hazard rate.

% H = hazard rate
% Bslope = exponent applied to LLR transfer function
% Bscale = gain factor applied to normalized non-linear LLR transfer function
% noise = divisive scaling factor applied to final belief


function CP = Glaze_sim_fast_npLLR_InconUp(LLR,nsamps,rLLR,H,noise,incon,gains)

% Apply non-parametric gain function to LLRs
gains = cumsum(gains);
gains = [fliplr(gains) 0 gains];  % creating full vector of gain terms, symmetric around LLR=0
rLLR = [sort(-rLLR) 0 rLLR];      % creating full vector of matching original LLRs

for s = 1:size(LLR,2)
    LLR(:,s) = interp1(rLLR,rLLR.*gains,LLR(:,s),'spline');
end

% Increment belief for each sample
LPRout = zeros(size(LLR,1),1);
for s = 1:size(LLR,2)
    LLR(abs(sign(LPRout(:,end))-sign(LLR(:,s)))==2,s) = LLR(abs(sign(LPRout(:,end))-sign(LLR(:,s)))==2,s).*incon;  % apply gain factor to new samples that are inconsistent with current belief
    LPRout(:,end+1) = LLR(:,s)+LPRout(:,end)+log(((1-H)/H)+exp(-LPRout(:,end)))-log(((1-H)/H)+exp(LPRout(:,end)));
end

% Retrieve final LPRs for each trial (accounting for variable sequence lengths)
subinds = sub2ind(size(LPRout),1:size(LPRout,1),nsamps'+1);
LPRfinal = LPRout(subinds)';

% Calculate choice probabilities based on LPR @ end of each sequence, scaled by noise
CP = 0.5+0.5.*erf(LPRfinal./noise);